---
title: Lambda
weight: 500
---

{{< toc >}}

Quick examples:

```
(\x::String -> x ++ x)
foldr(\a::Integer b::Integer -> a + b, 0, [1, 2, 3, 4])
map((\x -> x + 1), [1, 2, 3, 4])
(\ _ -> ())
(\ _::String _::String -> true)
```

## Syntax

<pre>
\ <i>parameters</i> -> <i>expression</i>
</pre>

A parameter can have either an explicit or an inferred type, as well as an optional name.
The possible forms lambda parameter declarations can take are illustrated below.
You don't need to explicitly provide the return type.

```
\ x::Integer _::String y _ -> ...
```
The first parameter has an explicit name and type, the second has only an explicit type, the third has only an explicit name, and the final has neither a name nor a declared type.

## Semantics

Functions generated by a lambda expression have exactly the same semantics as a normal function.
They can be applied, partially applied, passed as parameters, etc.

Any values in scope are implicitly captured and can be used, even if the resulting function is passed outside the scope of the captured values.

There is really no interaction or special behavior with nonterminals/flow analysis/etc.
Decorated and undecorated nonterminals can be captured and used as parameters as expected.

